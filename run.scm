(import (chicken load))
(import (chicken process-context)
        (chicken port)
        args)

(load-relative "parse.scm")
(load-relative "simulation.scm")
(load-relative "sort.scm")

(define (run-simulation small-numbers large-numbers target population-capacity generations exit-success)
    (define operator-options (list + - / *))
    (define numbers (append small-numbers large-numbers))
    (define first-tree (create-one-tree numbers operator-options))
    (define trees (create-mutations first-tree population-capacity operator-options))
    (let simulation-loop ((trees (list))
                          (new-trees (create-mutations first-tree population-capacity operator-options))
                          (target target)
                          (population-capacity population-capacity)
                          (generations-remaining generations))
        (define number-of-trees (+ (length trees) (length new-trees)))
        (set! trees (insertion-sort (append trees (find-errors new-trees target))))
        (give-report trees generations-remaining)
        (check-success trees exit-success)
        (set! trees (cull-trees-by-half trees))
        (set! new-trees (reproduce-trees trees operator-options)) ; fails because it returns old trees
        (if (> generations-remaining 0)
            (simulation-loop trees new-trees target population-capacity (- generations-remaining 1)))))

; load the args
(define opts (list (args:make-option (s small)         (required: "SMALL")          "choose from 1:10 inclusive.   EG: -s 1,2,5,7")
                   (args:make-option (l large)         (required: "LARGE")          "choose from (25,50,75,100).   EG: -l 25,100")
                   (args:make-option (t target)        (required: "TARGET")         "a 3-digit integer 100:999.    EG: -t 340")
                   (args:make-option (p pop)           (required: "POPULATION")     "maximum number of algorithms. EG: -p 40")
                   (args:make-option (g gen)           (required: "generations")    "number of generations.        eg: -g 400")
                   (args:make-option (e exit)          #:none                       "exit on first success")
                   (args:make-option (h help)          #:none                       "Display this text")))

(define (usage)
    (with-output-to-port (current-error-port)
        (lambda ()
            (print "Usage: " (car (argv)) " [options...]")
            (newline)
            (print (args:usage opts))
            (print "Find it on Github at.")))
    (exit 1))

(receive (options operands)
    (args:parse (command-line-arguments) opts)

    (cond ((not (alist-ref 'small options))
           (print "missing small")
           (usage))
          ((not (alist-ref 'large options))
           (print "missing large")
           (usage))
          ((not (alist-ref 'target options))
           (print "missing target")
           (usage))
          ((not (alist-ref 'pop options))
           (print "missing population")
           (usage))
          ((not (alist-ref 'gen options))
           (print "missing generations")
           (usage)))
    
    (let ((small-numbers (parse-small-arg (alist-ref 'small options)))
          (large-numbers (parse-large-arg (alist-ref 'large options)))
          (target (parse-target-arg (alist-ref 'target options)))
          (population (parse-numeric-arg (alist-ref 'pop options)))
          (generations (parse-numeric-arg (alist-ref 'gen options)))
          (exit-success (alist-ref 'exit options)))
        (run-simulation small-numbers large-numbers target population generations exit-success)))
